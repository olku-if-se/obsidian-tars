# I18n Migration Plan – 2025-10-15 11:53

## Current Implementation Assessment
- `packages/plugin/src/lang/helper.ts` wires `t(key)` to a hard-coded `localeMap` with language detection tied to `window.localStorage`. The result is a partially typed, synchronous lookup with no namespace support or fallback chaining.
- Locale files (for example `packages/plugin/src/lang/locale/en.ts`) use full English sentences as keys, making refactors risky, discouraging reuse, and preventing tooling-driven extraction.
- Strings live directly inside feature code (`commands/`, `providers/`, `settings/`, etc.); there is no consistent strategy for parameterised messages, pluralisation, formatting, or validation that a key exists in every locale.
- The rest of the monorepo (`@tars/ui`, MCP host, docs) has started to embed user-facing strings as literals, so the ad hoc helper in the plugin cannot scale across packages.
- Translation updates require touching TypeScript modules, which is unfriendly for community contributors and impossible to automate with translation platforms or AI-assisted workflows.

## Target Capabilities
- Namespaced translation resources stored as structured JSON that can be linted, validated, and synced with translation tooling.
- A runtime translation service that handles locale detection (preferring Obsidian’s setting, then browser/OS, finally English), fallbacks, interpolation, and pluralisation.
- Type-safe lookup helpers so build-time checks catch missing keys or incorrect parameter usage.
- Tooling and docs that allow contributors (humans or AI) to add/maintain locales without touching TypeScript.
- Automated tests that cover critical translation paths and ensure bundle size remains acceptable.

## Proposed Architecture

### Libraries & Tooling
- Adopt `i18next` with the lightweight `i18next-browser-languagedetector` for runtime detection, and `i18next-resources-to-ts` (or similar) to emit TypeScript types from resource JSON.
- Add a thin wrapper (`packages/plugin/src/i18n/index.ts`) that:
  - bootstraps `i18next` with bundled JSON resources,
  - exposes `translate(key, options?)` with an alias `t`,
  - exposes helper hooks for React components (`useTranslation()` wrapper).
- Introduce an `npm run i18n:check` script that validates resource completeness (`i18next-resources-to-ts --outFile ...`) and fails CI when locales drift.

### File & Namespace Structure
- Move locale assets to `packages/plugin/src/i18n/locales/{lang}/{namespace}.json`; recommended namespaces:
  - `common` for shared labels and Notices,
  - `commands`, `settings`, `providers`, `prompt`, `statusBar`, etc. following existing folder names.
- Add `packages/plugin/src/i18n/resources.ts` to collect all namespaces per locale and export them for `i18next` initialisation.
- Keep autogenerated TypeScript definitions (`packages/plugin/src/i18n/generated/resources.d.ts`) out of source control if they can be regenerated; otherwise check them in and document regeneration steps.

### String Externalisation Strategy
- Define translation keys as dotted paths (`settings.general.enableDefaultSystemMessage`) instead of English literals.
- Support interpolation and pluralisation (e.g. `{{count}}` placeholders) through `i18next` options.
- For developer ergonomics, add ESLint/Biome rules or custom lint checks to prevent newly committed string literals that contain user-facing text in `src/`.

## Migration Plan by Release

### Release 1 – Foundation & Tooling
- Add `i18n` module scaffolding (config, locale loaders, typed helpers) without changing existing call sites. Expose a compatibility layer that proxies the current `t()` implementation to the new service so both systems can coexist.
- Author the canonical English resources by converting `packages/plugin/src/lang/locale/en.ts` to JSON files with stable keys. Provide a codemod/script to map English sentence keys to namespaced identifiers, keeping an alias map to avoid breakage.
- Introduce automated checks:
  - `npm run i18n:check` to validate resources,
  - unit tests for the detection/fallback logic,
  - CI step ensuring every locale has the same key set as English.
- Document the new conventions (`docs/i18n-styleguide.md`) and update contributor guides.

### Release 2 – Incremental Adoption in the Plugin
- Replace `packages/plugin/src/lang/helper.ts` with the new wrapper. Update core flows (`commands/*`, `settings/*`, `providers/*`, `prompt/*`) to use namespaced keys.
- Externalise parametrised strings and enforce interpolation patterns; add regression tests around critical notices/errors to guard against missing keys.
- Remove the legacy locale modules once the plugin builds exclusively from JSON resources.
- Ensure Obsidian language detection defers to the app’s locale (use `this.app.vault.getConfig('locale')` or equivalent) with a documented override in plugin settings.

### Release 3 – Cross-Package Adoption & Enhancements
- Roll the same infrastructure into `@tars/ui` and other workspaces so shared React components can consume translations through a single provider.
- Add React helpers (e.g. `<Trans />` component or a `useT()` hook) and storybook examples that demonstrate runtime language switching.
- Introduce lazy loading or code splitting if locale bundles threaten plugin size; verify esbuild config handles JSON imports efficiently.
- Expand automated coverage: add Vitest suites that render translated components under multiple locales.

### Release 4 – Community Translation & Automation
- Publish contribution docs describing the locale file layout, coding conventions, and `npm run i18n:check`.
- Wire optional translation-platform integration (e.g. Crowdin, Weblate, Lokalise) or provide a simple GitHub workflow that validates PR-supplied JSON and runs `i18n:check`.
- Add a `docs/i18n-progress.md` or badge summarising locales and completion percentage.
- Investigate AI-assisted translation scripts (e.g. `npm run i18n:machine <lang>`) that call supported providers when API keys are available, while flagging machine-generated entries for human review.

## Community Translation Workflow
- Store locale JSON files in a predictable hierarchy so contributors can copy `en` into a new language folder, translate values, and run `npm run i18n:check`.
- Provide a template PR checklist ensuring translators update `locales/<lang>/metadata.json` (for translator credit, locale name) and run unit tests.
- Add CI automation that comments on PRs when keys are missing or when JSON is malformed.
- Maintain a `docs/translations.md` page listing active maintainers per locale and linking to translation guidelines. Encourage incremental updates (single file/few keys) to reduce review friction.

## Risks & Mitigations
- **Bundle Size:** `i18next` plus multiple locales can inflate bundle size. Mitigate via namespace-based loading, minified JSON, and optionally bundling only `en` + selected locales while enabling dynamic imports for community packs.
- **Key Drift:** Enforce typed key generation and CI checks so English additions fail builds if other locales are missing updates; provide tooling to surface deltas to translators quickly.
- **Breaking Legacy Behaviour:** Maintain the existing `t` signature during the transition and ship telemetry/feature flags to revert if localisation fails in the field.
- **Contributor Overhead:** Offer clear docs, scripts, and automation so adding translations is approachable without deep TypeScript knowledge.

## Next Steps Snapshot
1. Land Release 1 scaffolding behind feature flags and run `npm run build && npm run test` to confirm no regression.
2. Compile an inventory of user-facing strings outside the plugin package (UI kit, docs) to schedule subsequent migrations.
3. Announce the plan in release notes and invite early translators to pilot the new workflow once Release 2 is complete.
