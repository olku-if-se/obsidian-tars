# Obsidian Tars Plugin DI Refactoring Plan v1.0
**Enhanced with Monorepo DI Patterns and Comprehensive Migration Strategy**

**Date**: 2025-10-20
**Target**: Complete internal redesign using `@needle-di/core`
**Monorepo Strategy**: Pattern 2 (Package Modules) + Token-Based Boundaries
**Approach**: Deep refactoring with incremental verification, no breaking changes

## Executive Summary

Building on the comprehensive analysis and existing DI documentation, this plan transforms the Obsidian Tars plugin from tightly coupled monolithic components to a clean, testable service-oriented architecture. The enhanced strategy incorporates proven monorepo DI patterns and leverages existing service contracts.

## Architecture Insights from Existing Documents

### Key Patterns Identified

#### 1. **Token-Based Package Boundaries** (from `dependency-injection-refactoring-guide.md`)
- **Rule 1**: Start with token creation for abstractions
- **Rule 2**: Apply `@injectable()` decorator to all service classes
- **Rule 3**: Constructor injection with default parameters
- **Rule 4**: Context objects for external dependencies

#### 2. **Package Module Pattern** (from `monorepo-di-patterns.md`)
- **Recommended for Medium Monorepo**: 10-30 packages (Tars has ~5 core packages)
- **Balance**: Explicit registration with encapsulated configuration
- **Pattern**: Each package exports a DI module that auto-registers its providers

#### 3. **Three-Phase Migration Strategy**
- **Phase 1**: Preparation (no breaking changes)
- **Phase 2**: Container setup and validation
- **Phase 3**: Gradual replacement with full DI adoption

## Enhanced Service Architecture

### Service Layer Design (Pattern 2: Package Modules)

#### Core Services (`@tars/plugin` package)

```typescript
// packages/plugin/src/services/GenerationService.ts
@injectable()
export class GenerationService implements IGenerationService {
  constructor(
    private messageService = inject(IMessage_SERVICE_TOKEN),
    private textService = inject(IText_SERVICE_TOKEN),
    private providerService = inject(IProvider_SERVICE_TOKEN),
    private context = inject(CONTEXT_TOKEN) // Plugin context
  ) {}
}

// packages/plugin/src/di/generation.module.ts
export class GenerationModule extends ContainerModule {
  constructor() {
    super((bind) => {
      bind(IGENERATION_SERVICE_TOKEN).to(GenerationService)
        .inSingletonScope();
    });
  }
}
```

#### MCP Services (`@tars/mcp-hosting` package)

```typescript
// packages/mcp-hosting/src/services/McpService.ts
@injectable()
export class McpService implements IMcpService {
  constructor(
    private serverManager = inject(MCP_SERVER_MANAGER_TOKEN),
    private executor = inject(TOOL_EXECUTOR_TOKEN),
    private processor = inject(CODE_BLOCK_PROCESSOR_TOKEN),
    private logger = inject(LOGGER_TOKEN)
  ) {}
}

// packages/mcp-hosting/src/di/mcp.module.ts
export class McpModule extends ContainerModule {
  constructor(private config: McpConfig) {
    super((bind) => {
      bind(IMCP_SERVICE_TOKEN).to(McpService)
        .inSingletonScope();
      bind(MCP_CONFIG_TOKEN).toConstantValue(config);
    });
  }
}
```

### Token Management Strategy (Pattern 1: Token-Based)

#### Centralized Tokens in `@tars/contracts`

```typescript
// packages/contracts/src/tokens/plugin.tokens.ts
export const IGENERATION_SERVICE_TOKEN = createToken<IGenerationService>('GenerationService');
export const IMESSAGE_SERVICE_TOKEN = createToken<IMessageService>('MessageService');
export const ITEXT_SERVICE_TOKEN = createToken<ITextService>('TextService');
export const IPROVIDER_SERVICE_TOKEN = createToken<IProviderService>('ProviderService');

// packages/contracts/src/tokens/mcp.tokens.ts
export const IMCP_SERVICE_TOKEN = createToken<IMcpService>('McpService');
export const MCP_SERVER_MANAGER_TOKEN = createToken<IMCPServerManager>('MCPServerManager');
export const TOOL_EXECUTOR_TOKEN = createToken<IToolExecutor>('ToolExecutor');
```

#### Context Objects for External Dependencies

```typescript
// packages/plugin/src/context/PluginContext.ts
export interface PluginContext {
  readonly app: App;
  readonly plugin: Plugin;
  readonly settings: PluginSettings;
  readonly vault: Vault;
}

// packages/plugin/src/di/context.module.ts
export class ContextModule extends ContainerModule {
  constructor(private app: App, private plugin: Plugin, private settings: PluginSettings) {
    super((bind) => {
      bind(CONTEXT_TOKEN).toConstantValue({
        app,
        plugin,
        settings,
        vault: app.vault
      });
    });
  }
}
```

## Migration Strategy: Three-Phase Approach

### Phase 1: Preparation (Week 1) - No Breaking Changes

#### 1.1 Identify Service Boundaries
**Current Monolithic Files → Target Services:**

| Current File | Lines | Target Services | Primary Responsibilities |
|--------------|--------|----------------|----------------------|
| `main.ts` | 895 | PluginLifecycleService, CommandService, DIBootstrapService | Plugin orchestration, command registration, container setup |
| `editor.ts` | 795 | GenerationService, MessageService, TextService | Text generation, conversation parsing, text manipulation |
| `toolCallingCoordinator.ts` | 685 | ToolCallingService, ToolExecutionService, ConversationService | AI tool calling, tool execution, multi-turn conversations |

#### 1.2 Extract Interfaces (Backward Compatible)

```typescript
// packages/plugin/src/interfaces/editor.ts
// New interfaces extracted from editor.ts
export interface IMessageService {
  extractMessages(editor: Editor, cursor?: CursorPosition): Promise<Message[]>;
  formatMessage(role: string, content: string): string;
  buildConversation(messages: Message[]): Conversation;
}

// Keep existing function for backward compatibility
export function generateLegacy(...) {
  // Existing implementation that will be gradually replaced
}
```

#### 1.3 Create Injection Tokens

```typescript
// packages/plugin/src/tokens/index.ts
export const IMESSAGE_SERVICE_TOKEN = createToken<IMessageService>('MessageService');
export const IGENERATION_SERVICE_TOKEN = createToken<IGenerationService>('GenerationService');
export const ITEXT_SERVICE_TOKEN = createToken<ITextService>('TextService');

// Legacy support tokens (optional injection)
export const LEGACY_GENERATE_TOKEN = createToken<LegacyGenerateFunction>('LegacyGenerate');
```

#### 1.4 Add `@injectable()` Decorators (Backward Compatible)

```typescript
// Before (still works)
class LegacyService {
  constructor(private dep?: any) {}
}

// After (DI-ready)
@injectable()
class LegacyService {
  constructor(
    private newDep = inject(IMESSAGE_SERVICE_TOKEN, { optional: true }),
    private legacyParam?: OldType
  ) {
    // Handle both patterns during migration
  }
}
```

### Phase 2: Container Setup (Week 2)

#### 2.1 Create Package Modules

```typescript
// packages/plugin/src/di/plugin.module.ts
export class PluginModule extends ContainerModule {
  constructor(
    private app: App,
    private plugin: Plugin,
    private settings: PluginSettings
  ) {
    super((bind) => {
      // Load context first
      this.loadContext(bind);

      // Load service modules
      this.loadServices(bind);

      // Load MCP integration
      this.loadMcpIntegration(bind);
    });
  }

  private loadContext(bind: interfaces.Bind) {
    bind(CONTEXT_TOKEN).toConstantValue({
      app: this.app,
      plugin: this.plugin,
      settings: this.settings,
      vault: this.app.vault
    });
  }

  private loadServices(bind: interfaces.Bind) {
    // Core services
    bind(IGENERATION_SERVICE_TOKEN).to(GenerationService).inSingletonScope();
    bind(IMESSAGE_SERVICE_TOKEN).to(MessageService).inSingletonScope();
    bind(ITEXT_SERVICE_TOKEN).to(TextService).inSingletonScope();
    bind(IPROVIDER_SERVICE_TOKEN).to(ProviderService).inSingletonScope();

    // Infrastructure services
    bind(ICOMMAND_SERVICE_TOKEN).to(CommandService).inSingletonScope();
    bind(ITAG_SERVICE_TOKEN).to(TagService).inSingletonScope();
  }

  private loadMcpIntegration(bind: interfaces.Bind) {
    // MCP services - uncomment and fix existing commented code
    bind(IMCP_SERVICE_TOKEN).to(McpService).inSingletonScope();
    bind(MCP_SERVER_MANAGER_TOKEN).to(MCPServerManager).inSingletonScope();
    bind(TOOL_EXECUTOR_TOKEN).to(ToolExecutor).inSingletonScope();
    bind(CODE_BLOCK_PROCESSOR_TOKEN).to(CodeBlockProcessor).inSingletonScope();
  }
}
```

#### 2.2 Create Root Container Factory

```typescript
// packages/plugin/src/di/container.factory.ts
export function createPluginContainer(
  app: App,
  plugin: Plugin,
  settings: PluginSettings
): Container {
  const container = new Container();

  // Load modules in dependency order
  container.load(
    new ContextModule(app, plugin, settings),
    new PluginModule(app, plugin, settings),
    new McpModule(settings.mcpServers),
    new LoggerModule(), // From @tars/logger
    new StreamsModule()  // From @tars/streams
  );

  // Validate all dependencies resolve
  try {
    container.validate();
    console.log('✅ DI container validation passed');
  } catch (error) {
    console.error('❌ DI container validation failed:', error);
    throw new Error(`Dependency injection configuration invalid: ${error.message}`);
  }

  return container;
}
```

#### 2.3 Create Service Implementations

```typescript
// packages/plugin/src/services/GenerationService.ts
@injectable()
export class GenerationService implements IGenerationService {
  constructor(
    private messageService = inject(IMESSAGE_SERVICE_TOKEN),
    private textService = inject(ITEXT_SERVICE_TOKEN),
    private providerService = inject(IPROVIDER_SERVICE_TOKEN),
    private mcpService = inject(IMCP_SERVICE_TOKEN),
    private context = inject(CONTEXT_TOKEN)
  ) {}

  async generateWithProvider(params: GenerationParams): Promise<void> {
    const conversation = await this.messageService.extractMessages(params.env);
    const context = this.buildRequestContext(params.editor, params.provider);

    // Delegate to provider service with MCP tools
    const mcpTools = await this.mcpService.getToolContext();
    await this.providerService.generateResponse(conversation, context, mcpTools);
  }
}
```

### Phase 3: Gradual Replacement (Week 3)

#### 3.1 Simplify Main Plugin

```typescript
// Before: 895 lines of manual orchestration
export default class TarsPlugin extends Plugin {
  statusBarManager: StatusBarController
  mcpManager: MCPServerManager | null = null
  mcpExecutor: ToolExecutor | null = null
  mcpCodeBlockProcessor: CodeBlockProcessor | null = null
  // ... 15+ other properties

  async onload() {
    // 100+ lines of manual setup
    this.setupStatusBar()
    this.setupMcp()
    this.registerCommands()
  }
}

// After: Clean delegation to services
export default class TarsPlugin extends Plugin {
  private container: Container
  private commandService: ICommandService
  private mcpService: IMcpService
  private generationService: IGenerationService

  async onload() {
    // Initialize DI container
    this.container = createPluginContainer(this.app, this, this.settings);

    // Resolve services
    this.commandService = this.container.resolve(ICOMMAND_SERVICE_TOKEN);
    this.mcpService = this.container.resolve(IMCP_SERVICE_TOKEN);
    this.generationService = this.container.resolve(IGENERATION_SERVICE_TOKEN);

    // Initialize MCP
    await this.mcpService.initialize(this.settings.mcpServers);

    // Register commands through service
    this.commandService.registerCommands();
  }
}
```

#### 3.2 Eliminate Parameter Explosion

```typescript
// Before: 7+ manual dependencies
export const createCommand = (
  meta: TagCmdMeta,
  app: App,
  settings: PluginSettings,
  statusBarManager: any,
  requestController: RequestController,
  mcpManager?: unknown,
  mcpExecutor?: unknown
) => { /* ... */ }

// After: Single service dependency
@injectable()
export class CommandService implements ICommandService {
  constructor(
    private generationService = inject(IGENERATION_SERVICE_TOKEN),
    private mcpService = inject(IMCP_SERVICE_TOKEN),
    private settingsService = inject(ISettingsService_TOKEN),
    private context = inject(CONTEXT_TOKEN)
  ) {}

  createTagCommand(meta: TagCmdMeta): Command {
    return {
      id: meta.id,
      name: meta.name,
      editorCallback: async (editor, view) => {
        const env = this.buildRunEnv(editor);
        const provider = this.settingsService.getProvider(meta.tag);

        await this.generationService.generateWithProvider({
          env,
          editor,
          provider,
          endOffset: this.getEndOffset(editor),
          statusBarManager: this.context.statusService,
          requestController: new RequestController()
        });
      }
    };
  }
}
```

#### 3.3 Refactor Editor Components

```typescript
// Extract from editor.ts (795 lines → focused services)
@injectable()
export class MessageService implements IMessageService {
  constructor(
    private context = inject(CONTEXT_TOKEN),
    private settingsService = inject(ISettingsService_TOKEN),
    private tagService = inject(ITAG_SERVICE_TOKEN)
  ) {}

  async extractMessages(editor: Editor, cursor?: CursorPosition): Promise<Message[]> {
    const text = editor.getValue();
    const position = cursor || editor.getCursor();

    // Extract conversation logic from editor.ts lines 177-348
    const messages: Message[] = [];
    const conversation = this.parseConversation(text, position);

    return conversation.messages.map(msg => ({
      role: msg.role,
      content: this.sanitizeContent(msg.content)
    }));
  }
}

@injectable()
export class TextService implements ITextService {
  constructor(
    private writeLock = inject(DOCUMENT_WRITE_LOCK_TOKEN),
    private streamFactory = inject(TEXT_EDIT_STREAM_FACTORY_TOKEN)
  ) {}

  async insertText(editor: Editor, text: string, position?: number): Promise<void> {
    // Text insertion logic from editor.ts lines 358-393
    const lock = await this.writeLock.acquire(editor);

    try {
      const stream = this.streamFactory.create(editor);
      await stream.insert(text, position);
    } finally {
      await lock.release();
    }
  }
}
```

## Implementation Strategy: One Big Change with Verification

### Pre-Migration Validation

#### 1. Service Boundary Analysis
```typescript
// Automated analysis of current codebase
const serviceBoundaries = analyzeMonolithicFiles([
  { file: 'main.ts', targetServices: ['PluginLifecycleService', 'CommandService'] },
  { file: 'editor.ts', targetServices: ['GenerationService', 'MessageService', 'TextService'] },
  { file: 'toolCallingCoordinator.ts', targetServices: ['ToolCallingService', 'ToolExecutionService'] }
]);
```

#### 2. Dependency Graph Validation
```typescript
// Validate no circular dependencies before implementation
const dependencyGraph = buildDependencyGraph(serviceBoundaries);
assertNoCircularDependencies(dependencyGraph);
```

### Implementation Approach

#### 1. **Greenfield Service Creation**
- Create new service classes with DI interfaces
- Keep existing functions operational
- Gradually delegate calls to services

#### 2. **Validation at Each Step**
```typescript
// After each service implementation
validateServiceImplementation(service);
validateDependencyResolution(container);
validateBackwardCompatibility();
```

#### 3. **Final Switchover**
```typescript
// Once all services are validated
switchToDiImplementation();
removeLegacyCode();
runFullIntegrationTests();
```

## Enhanced Testing Strategy

### Unit Testing with DI Containers

```typescript
// tests/services/GenerationService.test.ts
describe('GenerationService', () => {
  let testContainer: Container;
  let service: GenerationService;

  beforeEach(() => {
    testContainer = new Container();

    // Mock cross-package dependencies
    testContainer.bind(IMESSAGE_SERVICE_TOKEN).toValue({
      extractMessages: vi.fn().mockResolvedValue([])
    });

    testContainer.bind(ITEXT_SERVICE_TOKEN).toValue({
      insertText: vi.fn()
    });

    testContainer.bind(IPROVIDER_SERVICE_TOKEN).toValue({
      generateResponse: vi.fn()
    });

    testContainer.bind(IMCP_SERVICE_TOKEN).toValue({
      getToolContext: vi.fn().mockResolvedValue([])
    });

    // Create service with mocked dependencies
    service = testContainer.resolve(GenerationService);
  });

  it('should generate response with MCP tools', async () => {
    const mockMessages = [/* ... */];
    const mockTools = [/* ... */];

    // Configure mocks
    testContainer.get(IMESSAGE_SERVICE_TOKEN).extractMessages
      .mockResolvedValue(mockMessages);
    testContainer.get(IMCP_SERVICE_TOKEN).getToolContext
      .mockResolvedValue(mockTools);

    await service.generateWithProvider(testParams);

    expect(testContainer.get(IPROVIDER_SERVICE_TOKEN).generateResponse)
      .toHaveBeenCalledWith(mockMessages, expect.anything(), mockTools);
  });
});
```

### Integration Testing

```typescript
// tests/integration/DiContainer.test.ts
describe('DI Container Integration', () => {
  it('should resolve all plugin dependencies', () => {
    const app = createMockApp();
    const plugin = createMockPlugin();
    const settings = createMockSettings();

    const container = createPluginContainer(app, plugin, settings);

    // Test all critical services can be resolved
    expect(() => container.resolve(IGENERATION_SERVICE_TOKEN)).not.toThrow();
    expect(() => container.resolve(IMCP_SERVICE_TOKEN)).not.toThrow();
    expect(() => container.resolve(ICOMMAND_SERVICE_TOKEN)).not.toThrow();
  });

  it('should support MCP integration through DI', async () => {
    const container = createPluginContainer(app, plugin, settings);
    const mcpService = container.resolve(IMCP_SERVICE_TOKEN);

    await mcpService.initialize(settings.mcpServers);
    expect(mcpService.isInitialized()).toBe(true);
  });
});
```

## Performance Optimization

### Lazy Loading for Expensive Services

```typescript
// Only initialize MCP when actually used
@injectable()
export class McpService implements IMcpService {
  private initialized = false;

  constructor(
    private heavyManager = inject(lazy(() => MCPServerManager))
  ) {}

  async initialize(configs: McpServerConfig[]): Promise<void> {
    if (!this.initialized) {
      const manager = this.heavyManager();
      await manager.initialize(configs);
      this.initialized = true;
    }
  }
}
```

### Service Lifecycle Management

```typescript
// Singleton: Stateless services (shared instance)
container.bind(LOGGER_TOKEN).to(ConsoleLogger).inSingletonScope();

// Scoped: Document-specific context
container.bind(DOCUMENT_CONTEXT_TOKEN)
  .to(DocumentContext)
  .inRequestScope();

// Transient: New instance per injection
container.bind(REQUEST_HANDLER_TOKEN)
  .to(RequestHandler)
  .inTransientScope();
```

## Risk Mitigation

### Potential Risks and Solutions

| Risk | Probability | Impact | Mitigation Strategy |
|------|------------|--------|-------------------|
| DI Container Setup Failures | Medium | High | Container validation before usage, graceful fallbacks |
| Circular Dependencies | Low | High | Dependency analysis tools, interface extraction |
| Performance Regression | Medium | Medium | Profile before/after, lazy loading, proper lifecycles |
| Breaking Changes | Low | High | Backward compatibility during Phase 1, comprehensive testing |
| MCP Integration Issues | Medium | High | Fix existing commented MCP DI code first |

### Fallback Strategy

```typescript
// Fallback to legacy pattern if DI fails
class PluginWithFallback extends Plugin {
  private useDi = true;

  async onload() {
    try {
      this.container = createPluginContainer(this.app, this, this.settings);
      this.container.validate();
      console.log('✅ DI initialization successful');
    } catch (error) {
      console.warn('⚠️ DI initialization failed, falling back to legacy mode:', error);
      this.useDi = false;
      this.setupLegacyMode();
    }
  }
}
```

## Success Criteria

### Functional Requirements
- ✅ All existing functionality preserved
- ✅ MCP integration fully functional through DI
- ✅ Commands work without manual dependency passing
- ✅ Plugin loads and initializes correctly
- ✅ Container validation passes on startup

### Quality Requirements
- ✅ All services follow single responsibility principle
- ✅ Dependencies are explicit through constructor injection
- ✅ Code is fully unit testable with mocked dependencies
- ✅ Service boundaries are clear and maintainable
- ✅ No circular dependencies exist

### Performance Requirements
- ✅ No performance regression in plugin startup
- ✅ Text generation performance maintained or improved
- ✅ Memory usage optimized through proper lifecycles
- ✅ DI container resolution overhead < 5%

## Implementation Timeline

**Total Estimated Effort**: 3 weeks

### Week 1: Phase 1 - Preparation
- **Days 1-2**: Extract interfaces from monolithic files
- **Days 3-4**: Create injection tokens and service contracts
- **Days 5-6**: Add `@injectable()` decorators with backward compatibility
- **Day 7**: Validation and testing of preparation work

### Week 2: Phase 2 - Container Setup
- **Days 1-2**: Create package modules for each service layer
- **Days 3-4**: Implement service classes with DI constructor injection
- **Days 5-6**: Set up root container factory with validation
- **Day 7**: Container testing and MCP integration fix

### Week 3: Phase 3 - Gradual Replacement
- **Days 1-3**: Simplify main plugin and eliminate parameter explosion
- **Days 4-5**: Refactor editor components into focused services
- **Days 6-7**: Final validation, performance testing, and documentation

## Build Configuration Updates

### TypeScript Configuration
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "paths": {
      "@tars/*": ["packages/*/src"]
    }
  }
}
```

### Package Dependencies
```json
{
  "dependencies": {
    "@needle-di/core": "^1.0.0",
    "@tars/contracts": "workspace:*",
    "@tars/logger": "workspace:*",
    "@tars/streams": "workspace:*",
    "@tars/mcp-hosting": "workspace:*"
  }
}
```

## Conclusion

This enhanced DI refactoring plan v1.0 incorporates proven monorepo patterns and comprehensive migration strategies from the existing documentation. By using **Pattern 2 (Package Modules)** with **Token-Based Boundaries**, we achieve:

- **Explicit dependency management** with clear package boundaries
- **Backward compatibility** during migration with no breaking changes
- **Comprehensive testing** at unit, integration, and container levels
- **Performance optimization** through proper lifecycles and lazy loading
- **Risk mitigation** with validation at each step and fallback mechanisms

The three-phase approach ensures a smooth transition from the current tightly coupled architecture to a clean, maintainable, and highly testable service-oriented architecture using modern dependency injection patterns.