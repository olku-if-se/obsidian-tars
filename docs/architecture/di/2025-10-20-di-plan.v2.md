# Needle DI Migration Plan v2 (2025-10-20-140745)

## Source Inputs
- `docs/architecture/di/dependency-injection-refactoring-guide.md`
- `docs/architecture/di/monorepo-di-patterns.md`
- Prior plan (`docs/archive/2025-10-20-135506-di-refactoring-plan.md`)

## Strategic Objectives
- Adopt Needle DI idioms (`@injectable()`, `inject(token)`, context objects) across the plugin package.
- Define token-first contracts in `@tars/contracts` to enable package decoupling and mockable seams.
- Align plugin internals with monorepo DI patterns so shared logic can live in future packages (e.g., `plugin-core`, `settings-ui`, `mcp-orchestration`).
- Enforce single-responsibility modules and make container configuration explicit while avoiding the service locator pattern.

## Architectural Guardrails
- **Composition Root Ownership**: A single `buildPluginContainer(context)` in `packages/plugin` constructs the container. Every other module relies solely on constructor/default-parameter injection.
- **Token Registry in Core**: Move all shared tokens/interfaces to `@tars/contracts` (or a new `@tars/core-di`) using `createToken<T>()`. Feature packages import tokens but never define cross-package symbols.
- **Context Objects for Framework Dependencies**: Wrap Obsidian APIs, React bridge handles, and runtime configuration in immutable context objects bound at root (per DI guide Rule 4).
- **Package Modules**: Each package exposes a `registerX(container)` (manual registration favored per monorepo patterns). Optionally adopt module descriptors later if scale warrants.
- **Lifecycle Awareness**: Honor async providers via `container.getAsync()` and ensure cleanup/disposal hooks are wired (per DI guide “Async Service Resolution”).
- **No Service Locator**: Prohibit `container.get()` outside the composition root; lint rule or review checklist required.

## Token & Interface Work
1. **Catalog Services**  
   - Logging, notification, status, settings, document, MCP, command orchestration, prompt generation, React bridge, editor utilities.
2. **Define Interfaces in Contracts**  
   - For each service, ensure `@tars/contracts` exports the interface. Add missing domain interfaces (e.g., `TagCommandService`, `PromptGenerationService`, `McpStartupOrchestrator`).
3. **Create Tokens**  
   - Introduce `createToken<T>('Identifier')` helpers. Provide optional factory for tree-shakable or lazily created services (per DI guide).
4. **Context Tokens**  
   - `PluginContextToken` (app, plugin, vault, workspace), `ReactContextToken`, `ObsidianNoticeToken`, etc.

## Monorepo Packaging Strategy
- **Short Term**: Keep implementations in `packages/plugin`, but restructure into feature folders with DI modules (`services/registerCoreServices.ts`, `commands/registerCommands.ts`).
- **Mid Term**: Extract DI-agnostic logic into a new `packages/plugin-core` that depends only on tokens/interfaces. `packages/plugin` hosts Obsidian adapters bound to those tokens.
- **Long Term**: Consider distinct packages for MCP orchestration and settings UI once DI seams are stable. Follow token-based package boundaries (Monorepo pattern 1) before considering auto-discovery modules.

## Refactoring Workstreams
### Phase 1 – Container Foundations
- Implement `buildPluginContainer(context: PluginContext): Container`.
- Replace Inversify-style `.bind().toClass()` with Needle equivalents: `container.bind(FooService);` or `container.bind(TOKEN).toFactory(...)`.
- Annotate all services/commands with `@injectable()` and shift to constructor/default-parameter injection.
- Create test container factory using tokens for Vitest suites.

### Phase 2 – Core Services & Contexts
- Split `ObsidianSettingsService` into `SettingsRepository` (vault I/O) and `SettingsWatchService`.
- Introduce `StatusBarStateStore` + `StatusBarViewController` to replace monolithic status managers.
- Ensure each service consumes context tokens instead of direct Obsidian globals.

### Phase 3 – Commands & Editor
- Author `commands/registerCommands(container)` that wires Obsidian command registration via injected handlers.
- Break tag command logic into dedicated services (`TagCommandExecutor`, `PromptInsertionService`).
- Replace direct `new Notice()`/`logger` imports with injected dependencies (per DI guide “Common Pitfalls”).

### Phase 4 – MCP Orchestration
- Create orchestrators: `McpStartupOrchestrator`, `McpStatusBroadcaster`, `CodeBlockExecutionController`.
- Bind MCP infrastructure (`MCPServerManager`, `ToolExecutor`, `CodeBlockProcessor`) via tokens with factories; plan to relocate neutral pieces into shared package.
- Implement optional/lazy injections to manage heavy components (per DI guide: lazy injection for circular/heavy deps).

### Phase 5 – Settings & React UI
- Introduce `SettingsViewController` and `SettingsAdapterService` to isolate React-specific logic.
- Bind React bridge via context token so UI packages can replace implementations.
- Prepare extraction path for settings/presentation logic into a future monorepo package.

### Phase 6 – Package Extraction (opt-in)
- Migrate pure business services into `packages/plugin-core`.
- Update build graph (tsconfig paths, package manifests) to reflect new dependencies.
- Provide migration guides and update tests to consume the new packages.

## Testing & Validation
- Update Vitest bootstrap to spin up a Needle container per suite with mock providers (per DI guide “Testing Strategy”).
- Add container validation step (custom script calling `container.validate?.()`).
- Introduce integration tests for command registration, MCP startup, and settings save flows via DI boundaries.
- Enforce lint rule forbidding service locator usage (`no-service-locator` custom rule or ESLint config).

## Tooling & Build Tasks
- Ensure `tsconfig` enables stage-3 decorators (`experimentalDecorators`, `emitDecoratorMetadata`, `target: ES2022`).
- Add Biome rule or scripted check to confirm tokens live only in shared packages.
- Extend `npm run test` pipeline with container smoke test and optional coverage target for new services.

## Deliverables & Checkpoints
1. **Architecture Docs** – Update `docs/architecture/di` with token map and context descriptions.
2. **Container Factory** – `packages/plugin/src/di/container.ts` + tests.
3. **Service Modules** – `registerCoreServices.ts`, `registerUiServices.ts`, `registerMcpServices.ts`.
4. **Command Registration** – Unified registration orchestrator resolved from container.
5. **Testing Harness** – Mock container utilities in `tests/` using tokens.
6. **Extraction ADR** – Decision record covering package split timing and dependencies.

## Risks & Mitigations
- **Circular Dependencies**: Use tokens + lazy injection; document detection strategy.
- **Obsidian API Coupling**: Context tokens abstract UI/runtime dependencies to ease future extraction.
- **Team Adoption**: Provide examples from the DI guide; host knowledge sharing session; codify code review checklist.
- **Performance**: Benchmark startup time before/after container rewrites; ensure lazy providers for heavy services.

## Open Questions
- What cadence should we follow for moving logic into `plugin-core` to avoid blocking feature work?
- Do we require scoped containers for per-editor workflows (child containers per note or session)?
- Should MCP orchestration tokens live in `@tars/contracts` or a new `@tars/mcp-core`?

