# Dependency Injection Refactoring Plan v3 - Obsidian Tars Plugin

**Created:** 2025-10-20-150000
**Updated:** Based on existing DI documentation and monorepo patterns
**Target:** Complete DI integration using @needle-di/core with hybrid approach
**Strategy:** Strangler Fig Pattern + Package Modules + Context-Based Migration

## Executive Summary

This plan combines the comprehensive refactoring approach with proven DI patterns from the existing documentation. We'll use a **Strangler Fig Pattern** with **Package Modules** for a gradual, low-risk migration that preserves functionality while building a clean DI architecture.

## Key Strategy Changes from v2

### 1. **Hybrid Migration Approach**
- **Primary:** Strangler Fig Pattern (gradually wrap and replace legacy components)
- **Implementation:** Package Modules Pattern (auto-discovery with manual override)
- **Context Integration:** Enhanced context pattern from existing documentation

### 2. **Monorepo-First Design**
Following the monorepo DI patterns, we'll create a shared core package for tokens and interfaces:
- `@tars/core` - Shared tokens, interfaces, and DI utilities
- `@tars/plugin` - Main application with DI container
- Existing packages (`@tars/logger`, `@tars/mcp-hosting`, etc.) enhanced with DI

### 3. **Phase-Based Rollout**
Instead of one big change, we'll use **Feature Flags** and **Gradual Replacement**:
- Phase 1: Infrastructure and shared package setup
- Phase 2: Package module creation with legacy compatibility
- Phase 3: Gradual service replacement with feature flags
- Phase 4: Legacy code removal

## Phase 1: Core Infrastructure Setup

### 1.1 Create @tars/core Package
**Target:** `packages/core/`

```typescript
// packages/core/src/tokens/index.ts
export const LOGGER_TOKEN = createToken<ILogger>('Logger');
export const SETTINGS_MANAGER_TOKEN = createToken<ISettingsManager>('SettingsManager');
export const DOCUMENT_CONTEXT_TOKEN = createToken<IDocumentContext>('DocumentContext');
export const CONVERSATION_EXTRACTOR_TOKEN = createToken<IConversationExtractor>('ConversationExtractor');
export const TEXT_INSERTER_TOKEN = createToken<ITextInserter>('TextInserter');
export const MCP_MANAGER_TOKEN = createToken<IMcpManager>('McpManager');
export const TOOL_EXECUTOR_TOKEN = createToken<IToolExecutor>('ToolExecutor');

// Context tokens
export const PLUGIN_CONTEXT_TOKEN = createToken<IPluginContext>('PluginContext');
export const DOCUMENT_CONTEXT_PROVIDER_TOKEN = createToken<IDocumentContextProvider>('DocumentContextProvider');
export const CONVERSATION_CONTEXT_TOKEN = createToken<IConversationContext>('ConversationContext');
```

```typescript
// packages/core/src/interfaces/contexts.ts
export interface IPluginContext {
  readonly app: App;
  readonly plugin: TarsPlugin;
  readonly settings: PluginSettings;
  readonly statusBar: HTMLElement;
  readonly vault: Vault;
}

export interface IDocumentContext {
  readonly document: TFile;
  readonly editor: Editor;
  readonly documentPath: string;
  readonly pluginContext: IPluginContext;
}

export interface IConversationContext {
  readonly documentContext: IDocumentContext;
  readonly messages: Message[];
  readonly conversationRange: ConversationRange;
}
```

```typescript
// packages/core/src/interfaces/services.ts
export interface ILogger {
  log(message: string, meta?: any): void;
  error(message: string, error?: Error, meta?: any): void;
  debug(message: string, meta?: any): void;
}

export interface ISettingsManager {
  getSettings(): PluginSettings;
  updateSettings(updates: Partial<PluginSettings>): Promise<void>;
  getProviderSettings(providerId: string): ProviderSettings | undefined;
}

export interface IConversationExtractor {
  extractConversation(editor: Editor, context: IDocumentContext): Conversation;
}

export interface ITextInserter {
  insertStreamingResponse(
    editor: Editor,
    stream: AsyncGenerator<string>,
    insertionPoint: number,
    context: IDocumentContext
  ): Promise<void>;
}
```

### 1.2 Package Module Pattern Setup
**Target:** Each package exports a DI module

```typescript
// packages/core/src/core.module.ts
import { ContainerModule } from '@needle-di/core';
import { LOGGER_TOKEN, SETTINGS_MANAGER_TOKEN } from './tokens';

export class CoreModule extends ContainerModule {
  constructor() {
    super((bind) => {
      // Core infrastructure bindings
      bind(LOGGER_TOKEN).to(DebugLogger).inSingletonScope();
      bind(SETTINGS_MANAGER_TOKEN).to(SettingsManager).inSingletonScope();
    });
  }
}
```

```typescript
// packages/logger/src/logger.module.ts
import { ContainerModule } from '@needle-di/core';
import { LOGGER_TOKEN } from '@tars/core';
import { Logger } from './logger';

export class LoggerModule extends ContainerModule {
  constructor(config?: LoggerConfig) {
    super((bind) => {
      if (config) {
        bind(LOGGER_CONFIG_TOKEN).toConstantValue(config);
      }
      bind(LOGGER_TOKEN).to(Logger).inSingletonScope();
    });
  }
}
```

### 1.3 Enhanced Context Providers
Following the existing documentation patterns:

```typescript
// packages/core/src/providers/plugin-context.provider.ts
@injectable()
export class PluginContextProvider {
  private context: IPluginContext | null = null;

  initialize(app: App, plugin: TarsPlugin, settings: PluginSettings): void {
    this.context = Object.freeze({
      app,
      plugin,
      settings,
      statusBar: plugin.addStatusBarItem(),
      vault: app.vault
    });
  }

  getContext(): IPluginContext {
    if (!this.context) {
      throw new Error('PluginContextProvider not initialized');
    }
    return this.context;
  }
}
```

```typescript
// packages/core/src/providers/document-context.provider.ts
@injectable()
export class DocumentContextProvider {
  constructor(
    private pluginContextProvider: PluginContextProvider
  ) {}

  createContext(document: TFile, editor: Editor): IDocumentContext {
    const pluginContext = this.pluginContextProvider.getContext();

    return Object.freeze({
      document,
      editor,
      documentPath: document.path,
      pluginContext
    });
  }
}
```

## Phase 2: Service Migration with Legacy Compatibility

### 2.1 Strangler Fig Pattern Implementation

**Strategy:** Create new DI services alongside legacy classes, then gradually migrate callers.

```typescript
// packages/plugin/src/services/conversation-extractor.service.ts
@injectable()
export class ConversationExtractorService implements IConversationExtractor {
  constructor(
    private messageParser: IMessageParser,
    private conversationValidator: IConversationValidator,
    private logger: ILogger
  ) {}

  extractConversation(editor: Editor, context: IDocumentContext): Conversation {
    this.logger.debug('Extracting conversation', { documentPath: context.documentPath });

    const text = editor.getValue();
    const messages = this.messageParser.parse(text);
    const validatedConversation = this.conversationValidator.validate(messages);

    return {
      messages: validatedConversation,
      range: this.findConversationRange(editor, validatedConversation),
      documentContext: context
    };
  }

  private findConversationRange(editor: Editor, messages: Message[]): ConversationRange {
    // Implementation
  }
}
```

### 2.2 Legacy Wrapper Pattern
**Bridge between old and new systems:**

```typescript
// packages/plugin/src/wrappers/editor.wrapper.ts
export class EditorWrapper {
  constructor(
    private conversationExtractor: IConversationExtractor,
    private textInserter: ITextInserter,
    private settingsManager: ISettingsManager,
    private legacyMode: boolean = true
  ) {}

  // Legacy method signature that internal code still uses
  generate(editor: Editor, document: TFile): Promise<void> {
    if (this.legacyMode) {
      return this.legacyGenerate(editor, document);
    } else {
      return this.diGenerate(editor, document);
    }
  }

  private async legacyGenerate(editor: Editor, document: TFile): Promise<void> {
    // Call original legacy implementation
    return LegacyEditor.prototype.generate.call(this, editor, document);
  }

  private async diGenerate(editor: Editor, document: TFile): Promise<void> {
    const documentContext = this.createDocumentContext(document, editor);
    const conversation = this.conversationExtractor.extractConversation(editor, documentContext);

    // Use DI services for generation
    return this.textInserter.insertStreamingResponse(
      editor,
      conversation.stream,
      conversation.insertionPoint,
      documentContext
    );
  }
}
```

### 2.3 Feature Flag Integration
**Gradual rollout control:**

```typescript
// packages/core/src/interfaces/feature-flags.ts
export interface IFeatureFlags {
  useDIConversationExtractor(): boolean;
  useDITextInserter(): boolean;
  useDIMcpServices(): boolean;
  useDIStatusBar(): boolean;
}

@injectable()
export class FeatureFlagService implements IFeatureFlags {
  constructor(private settingsManager: ISettingsManager) {}

  useDIConversationExtractor(): boolean {
    return this.settingsManager.getSettings().featureFlags?.diConversationExtractor ?? false;
  }

  useDITextInserter(): boolean {
    return this.settingsManager.getSettings().featureFlags?.diTextInserter ?? false;
  }

  // ... other flags
}
```

### 2.4 Package Module Creation for Each Service Group

```typescript
// packages/plugin/src/modules/conversation.module.ts
export class ConversationModule extends ContainerModule {
  constructor() {
    super((bind, unbind, isBound, rebind) => {
      // Core conversation services
      bind(CONVERSATION_EXTRACTOR_TOKEN).to(ConversationExtractorService);
      bind(MESSAGE_PARSER_TOKEN).to(MessageParserService);
      bind(CONVERSATION_VALIDATOR_TOKEN).to(ConversationValidatorService);
      bind(TEXT_ENVIRONMENT_BUILDER_TOKEN).to(TextEnvironmentBuilderService);
    });
  }
}
```

```typescript
// packages/plugin/src/modules/mcp.module.ts
export class McpModule extends ContainerModule {
  constructor() {
    super((bind) => {
      bind(MCP_MANAGER_TOKEN).to(McpManagerService);
      bind(TOOL_EXECUTOR_TOKEN).to(ToolExecutorService);
      bind(TOOL_CALLING_COORDINATOR_TOKEN).to(ToolCallingCoordinatorService);
      bind(DOCUMENT_CACHE_MANAGER_TOKEN).to(DocumentCacheManagerService);
    });
  }
}
```

```typescript
// packages/plugin/src/modules/ui.module.ts
export class UiModule extends ContainerModule {
  constructor() {
    super((bind) => {
      bind(STATUS_BAR_STATE_MANAGER_TOKEN).to(StatusBarStateManagerService);
      bind(ERROR_LOG_MANAGER_TOKEN).to(ErrorLogManagerService);
      bind(MODAL_MANAGER_TOKEN).to(ModalManagerService);
      bind(COMMAND_REGISTRY_TOKEN).to(CommandRegistryService);
    });
  }
}
```

## Phase 3: Container Setup and Bootstrap

### 3.1 Main Container Configuration
**Target:** `packages/plugin/src/container/container.bootstrap.ts`

```typescript
// packages/plugin/src/container/container.bootstrap.ts
import { Container } from '@needle-di/core';
import { CoreModule } from '@tars/core';
import { LoggerModule } from '@tars/logger';
import { ConversationModule } from '../modules/conversation.module';
import { McpModule } from '../modules/mcp.module';
import { UiModule } from '../modules/ui.module';

export function createPluginContainer(app: App, plugin: TarsPlugin): Container {
  const container = new Container();

  // Load core infrastructure first
  container.load(new CoreModule());
  container.load(new LoggerModule());

  // Load feature modules
  container.load(new ConversationModule());
  container.load(new McpModule());
  container.load(new UiModule());

  // Register external dependencies
  container.bind(APP_TOKEN).toValue(app);
  container.bind(PLUGIN_TOKEN).toValue(plugin);

  // Initialize context providers
  const contextProvider = container.get(PLUGIN_CONTEXT_PROVIDER_TOKEN);
  const settings = container.get(SETTINGS_MANAGER_TOKEN);
  contextProvider.initialize(app, plugin, settings.getSettings());

  // Validate all dependencies
  container.validate();

  return container;
}
```

### 3.2 Feature Flag Service Integration
```typescript
// packages/plugin/src/services/feature-toggle.service.ts
@injectable()
export class FeatureToggleService {
  constructor(
    private featureFlags: IFeatureFlags,
    private container: Container
  ) {}

  getConversationExtractor(): IConversationExtractor {
    if (this.featureFlags.useDIConversationExtractor()) {
      return this.container.get(CONVERSATION_EXTRACTOR_TOKEN);
    } else {
      // Return legacy wrapper
      return new LegacyConversationExtractor();
    }
  }

  getTextInserter(): ITextInserter {
    if (this.featureFlags.useDITextInserter()) {
      return this.container.get(TEXT_INSERTER_TOKEN);
    } else {
      return new LegacyTextInserter();
    }
  }
}
```

### 3.3 Updated Plugin Entry Point
**Target:** `packages/plugin/src/main.ts`

```typescript
export default class TarsPlugin extends Plugin {
  private container: Container;
  private featureToggleService: FeatureToggleService;
  private legacyEditor: EditorWrapper;

  async onload() {
    console.log('Loading Obsidian Tars Plugin v' + this.manifest.version);

    // Initialize DI container
    this.container = createPluginContainer(this.app, this);

    // Get feature toggle service
    this.featureToggleService = this.container.get(FeatureToggleService);

    // Create wrapper that can switch between legacy and DI implementations
    this.legacyEditor = new EditorWrapper(
      this.featureToggleService.getConversationExtractor(),
      this.featureToggleService.getTextInserter(),
      this.container.get(SETTINGS_MANAGER_TOKEN)
    );

    // Initialize plugin with wrapper
    await this.initializePlugin();
  }

  private async initializePlugin(): Promise<void> {
    // Use wrapper for all legacy method calls
    // Existing code continues to work but can gradually switch to DI
    await this.legacyEditor.initializeCommands();
    await this.legacyEditor.initializeMcp();
    await this.legacyEditor.initializeStatusBar();
  }

  async onunload() {
    await this.legacyEditor.cleanup();
    console.log('Unloading Obsidian Tars Plugin');
  }
}
```

## Phase 4: Gradual Service Migration

### 4.1 Migration Order (Low Risk First)

#### **Phase 4.1: Infrastructure Services**
1. **Logger Service** - No dependencies, easy to verify
2. **Settings Manager** - Central, low-risk
3. **Context Providers** - Foundation for other services

#### **Phase 4.2: Isolated Services**
1. **Text Formatter** - Pure functions, easy to test
2. **Message Parser** - Well-defined input/output
3. **Conversation Validator** - Business logic only

#### **Phase 4.3: Core Services**
1. **Conversation Extractor** - Core but isolated
2. **Text Environment Builder** - Medium complexity
3. **Text Inserter** - Higher complexity but critical

#### **Phase 4.4: Complex Services**
1. **MCP Manager** - External dependencies
2. **Tool Executor** - Complex state management
3. **Tool Calling Coordinator** - Most complex

#### **Phase 4.5: UI Services**
1. **Error Log Manager** - Internal state only
2. **Modal Manager** - UI dependencies
3. **Status Bar Manager** - Many UI interactions

### 4.2 Migration Process per Service

#### **Step 1: Create DI Service**
```typescript
// New DI implementation
@injectable()
class NewConversationExtractor implements IConversationExtractor {
  constructor(
    private messageParser: IMessageParser,
    private logger: ILogger
  ) {}

  extractConversation(editor: Editor, context: IDocumentContext): Conversation {
    // New implementation
  }
}
```

#### **Step 2: Update Feature Flag**
```typescript
// Add to settings
interface PluginSettings {
  featureFlags: {
    diConversationExtractor: boolean;
    // ... other flags
  };
}
```

#### **Step 3: Update Wrapper**
```typescript
class EditorWrapper {
  getConversationExtractor(): IConversationExtractor {
    if (this.featureFlags.useDIConversationExtractor()) {
      return this.container.get(CONVERSATION_EXTRACTOR_TOKEN); // New service
    } else {
      return new LegacyConversationExtractor(); // Old implementation
    }
  }
}
```

#### **Step 4: Test and Deploy**
- Enable feature flag for testing
- Run test suite
- Monitor for issues
- Gradually roll out to all users

#### **Step 5: Remove Legacy Code**
```typescript
// After successful migration
class EditorWrapper {
  getConversationExtractor(): IConversationExtractor {
    // Only DI implementation remains
    return this.container.get(CONVERSATION_EXTRACTOR_TOKEN);
  }
}
```

### 4.3 Testing Strategy per Service

#### **Unit Tests for DI Services**
```typescript
// packages/plugin/tests/services/conversation-extractor.service.test.ts
describe('ConversationExtractorService', () => {
  let testContainer: Container;
  let conversationExtractor: IConversationExtractor;
  let mockMessageParser: jest.Mocked<IMessageParser>;
  let mockLogger: jest.Mocked<ILogger>;

  beforeEach(() => {
    testContainer = new Container();

    // Mock dependencies
    mockMessageParser = createMockMessageParser();
    mockLogger = createMockLogger();

    testContainer.bind(MESSAGE_PARSER_TOKEN).toValue(mockMessageParser);
    testContainer.bind(LOGGER_TOKEN).toValue(mockLogger);
    testContainer.bind(CONVERSATION_EXTRACTOR_TOKEN).to(ConversationExtractorService);

    conversationExtractor = testContainer.get(CONVERSATION_EXTRACTOR_TOKEN);
  });

  it('should extract conversation correctly', () => {
    // Test implementation
  });
});
```

#### **Integration Tests for Feature Flags**
```typescript
// packages/plugin/tests/integration/feature-toggle.test.ts
describe('Feature Toggle Integration', () => {
  let container: Container;
  let featureToggleService: FeatureToggleService;

  beforeEach(() => {
    container = createTestContainer();
    featureToggleService = new FeatureToggleService(
      container.get(IFeatureFlags),
      container
    );
  });

  it('should use legacy service when flag is false', () => {
    // Mock feature flag to false
    const service = featureToggleService.getConversationExtractor();
    expect(service).toBeInstanceOf(LegacyConversationExtractor);
  });

  it('should use DI service when flag is true', () => {
    // Mock feature flag to true
    const service = featureToggleService.getConversationExtractor();
    expect(service).toBeInstanceOf(ConversationExtractorService);
  });
});
```

## Phase 5: Package Structure Enhancement

### 5.1 Enhanced @tars/logger Package
```typescript
// packages/logger/src/index.ts
export { Logger } from './logger';
export { LoggerModule } from './logger.module';
export type { LoggerConfig } from './config';

// Export interfaces from core
export type { ILogger } from '@tars/core';
```

### 5.2 Enhanced @tars/mcp-hosting Package
```typescript
// packages/mcp-hosting/src/index.ts
export { McpManager } from './mcp-manager';
export { ToolExecutor } from './tool-executor';
export { McpModule } from './mcp.module';
export type { McpConfig, ToolConfig } from './config';

// DI integration
export { McpManagerService } from './services/mcp-manager.service';
export { ToolExecutorService } from './services/tool-executor.service';
```

### 5.3 New @tars/core Package Structure
```
packages/core/
├── src/
│   ├── index.ts              # Main exports
│   ├── tokens/               # All injection tokens
│   │   ├── index.ts
│   │   ├── logger.tokens.ts
│   │   ├── conversation.tokens.ts
│   │   └── mcp.tokens.ts
│   ├── interfaces/           # Service interfaces
│   │   ├── index.ts
│   │   ├── services.ts
│   │   ├── contexts.ts
│   │   └── feature-flags.ts
│   ├── providers/            # Context providers
│   │   ├── plugin-context.provider.ts
│   │   ├── document-context.provider.ts
│   │   └── conversation-context.provider.ts
│   ├── decorators/           # DI decorators
│   │   └── provider.decorator.ts
│   ├── utils/               # DI utilities
│   │   └── container.utils.ts
│   └── core.module.ts       # Core DI module
├── tests/
└── package.json
```

## Phase 6: Validation and Monitoring

### 6.1 Container Validation
```typescript
// packages/core/src/utils/container.validator.ts
export class ContainerValidator {
  static validate(container: Container): ValidationResult {
    const issues: string[] = [];

    try {
      // Check for missing providers
      const requiredTokens = [
        LOGGER_TOKEN,
        SETTINGS_MANAGER_TOKEN,
        PLUGIN_CONTEXT_PROVIDER_TOKEN,
        // ... other required tokens
      ];

      for (const token of requiredTokens) {
        try {
          container.get(token);
        } catch (error) {
          issues.push(`Missing provider for token: ${token}`);
        }
      }

      // Check for circular dependencies
      this.detectCircularDependencies(container, issues);

      return {
        isValid: issues.length === 0,
        issues
      };
    } catch (error) {
      return {
        isValid: false,
        issues: [`Container validation failed: ${error.message}`]
      };
    }
  }

  private static detectCircularDependencies(container: Container, issues: string[]): void {
    // Implementation for circular dependency detection
  }
}
```

### 6.2 Performance Monitoring
```typescript
// packages/core/src/utils/performance.monitor.ts
export class PerformanceMonitor {
  private static metrics = new Map<string, number[]>();

  static measureResolution<T>(token: InjectionToken<T>, container: Container): T {
    const start = performance.now();
    const result = container.get(token);
    const duration = performance.now() - start;

    this.recordMetric(`${token.toString()}_resolution`, duration);
    return result;
  }

  private static recordMetric(name: string, value: number): void {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }
    this.metrics.get(name)!.push(value);
  }

  static getMetrics(): Record<string, { avg: number; max: number; count: number }> {
    const result: Record<string, { avg: number; max: number; count: number }> = {};

    for (const [name, values] of this.metrics.entries()) {
      result[name] = {
        avg: values.reduce((a, b) => a + b, 0) / values.length,
        max: Math.max(...values),
        count: values.length
      };
    }

    return result;
  }
}
```

### 6.3 Feature Flag Analytics
```typescript
// packages/core/src/services/feature-flag.analytics.ts
@injectable()
export class FeatureFlagAnalytics {
  constructor(
    private logger: ILogger,
    private settingsManager: ISettingsManager
  ) {}

  logFeatureUsage(feature: string, enabled: boolean): void {
    this.logger.log('Feature flag usage', {
      feature,
      enabled,
      timestamp: new Date().toISOString(),
      version: this.settingsManager.getSettings().pluginVersion
    });
  }

  getFeatureUsageStats(): FeatureUsageStats {
    // Return usage statistics for monitoring
    return {
      diConversationExtractor: this.getUsageCount('diConversationExtractor'),
      diTextInserter: this.getUsageCount('diTextInserter'),
      // ... other features
    };
  }
}
```

## Implementation Timeline

### **Phase 1: Core Infrastructure** (3-4 days)
- Day 1-2: Create @tars/core package with tokens and interfaces
- Day 3: Implement context providers and base services
- Day 4: Create package module structure

### **Phase 2: Service Creation** (5-7 days)
- Day 1-2: Create new DI services for low-risk components
- Day 3-4: Create wrapper services with feature flag support
- Day 5-7: Implement feature flag service and toggle mechanism

### **Phase 3: Container Setup** (2-3 days)
- Day 1: Create container bootstrap configuration
- Day 2: Implement validation and monitoring
- Day 3: Update plugin entry point with DI support

### **Phase 4: Gradual Migration** (2-3 weeks)
- Week 1: Migrate infrastructure services (logger, settings, contexts)
- Week 2: Migrate isolated services (parsers, validators)
- Week 3: Migrate core services (extractor, inserter, builder)

### **Phase 5: Complex Services** (2-3 weeks)
- Week 1: Migrate MCP services
- Week 2: Migrate UI services
- Week 3: Final integration and cleanup

### **Phase 6: Validation** (1 week)
- Day 1-3: Comprehensive testing
- Day 4-5: Performance monitoring and optimization
- Day 6-7: Documentation and team training

**Total Timeline: 4-6 weeks**

## Risk Mitigation

### **Technical Risks**
1. **Breaking Changes:** Feature flags allow instant rollback
2. **Performance Issues:** Monitor container resolution times
3. **Memory Leaks:** Track service lifecycles with monitoring
4. **Circular Dependencies:** Container validation prevents startup

### **Migration Risks**
1. **Feature Flag Complexity:** Simple boolean flags initially
2. **Code Duplication:** Temporary and well-documented
3. **Team Confusion:** Clear documentation and training
4. **Testing Overhead:** Automated test generation templates

### **Operational Risks**
1. **Deployment Issues:** Gradual rollout with monitoring
2. **User Impact:** Feature flags allow targeted rollout
3. **Rollback Complexity:** One-click flag disable capability

## Success Metrics

### **Code Quality**
- [ ] Reduce cyclomatic complexity by 40%
- [ ] Eliminate direct service instantiation
- [ ] Achieve 90%+ test coverage for DI services
- [ ] Reduce average class size by 50%

### **Architecture**
- [ ] All services use constructor injection
- [ ] No circular dependencies detected
- [ ] Clear package boundaries with tokens
- [ ] Feature flags for all major services

### **Operational**
- [ ] Container validation passes
- [ ] Performance monitoring shows <10ms resolution time
- [ ] Feature flag analytics show successful migration
- [ ] Zero user-reported regressions

## Conclusion

This hybrid approach combines the safety of gradual migration with the benefits of modern DI architecture. By using the Strangler Fig Pattern with Feature Flags, we can:

- **Eliminate risk** through gradual, reversible changes
- **Maintain velocity** by shipping features during migration
- **Build expertise** incrementally across the team
- **Ensure quality** with comprehensive testing and monitoring
- **Enable rollback** instantly if issues arise

The result will be a maintainable, testable, and scalable codebase that follows modern dependency injection principles while preserving all existing functionality.